{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clearPointerElement = exports.addPointerElement = exports.translatePointer = exports.drawPointer = void 0;\nvar d3_1 = require(\"d3\");\nvar Pointer_1 = require(\"../types/Pointer\");\nvar arc_1 = require(\"./arc\");\nvar utils = __importStar(require(\"./utils\"));\nvar arcHooks = __importStar(require(\"./arc\"));\nvar GaugeComponentProps_1 = require(\"../types/GaugeComponentProps\");\nvar drawPointer = function (gauge, resize) {\n  var _a;\n  if (resize === void 0) {\n    resize = false;\n  }\n  gauge.pointer.current.context = setupContext(gauge);\n  var _b = gauge.pointer.current.context,\n    prevPercent = _b.prevPercent,\n    currentPercent = _b.currentPercent,\n    prevProgress = _b.prevProgress;\n  var pointer = gauge.props.pointer;\n  var isFirstTime = ((_a = gauge.prevProps) === null || _a === void 0 ? void 0 : _a.current.value) == undefined;\n  if ((isFirstTime || resize) && gauge.props.type != GaugeComponentProps_1.GaugeType.Grafana) initPointer(gauge);\n  var shouldAnimate = (!resize || isFirstTime) && pointer.animate;\n  if (shouldAnimate) {\n    gauge.doughnut.current.transition().delay(pointer.animationDelay).ease(pointer.elastic ? d3_1.easeElastic : d3_1.easeExpOut).duration(pointer.animationDuration).tween(\"progress\", function () {\n      var currentInterpolatedPercent = (0, d3_1.interpolateNumber)(prevPercent, currentPercent);\n      return function (percentOfPercent) {\n        var progress = currentInterpolatedPercent(percentOfPercent);\n        if (isProgressValid(progress, prevProgress, gauge)) {\n          if (gauge.props.type == GaugeComponentProps_1.GaugeType.Grafana) {\n            arcHooks.clearArcs(gauge);\n            arcHooks.drawArc(gauge, progress);\n            //arcHooks.setupArcs(gauge);\n          } else {\n            updatePointer(progress, gauge);\n          }\n        }\n        gauge.pointer.current.context.prevProgress = progress;\n      };\n    });\n  } else {\n    updatePointer(currentPercent, gauge);\n  }\n};\nexports.drawPointer = drawPointer;\nvar setupContext = function (gauge) {\n  var _a;\n  var value = gauge.props.value;\n  var pointer = gauge.props.pointer;\n  var pointerLength = pointer.length;\n  var minValue = gauge.props.minValue;\n  var maxValue = gauge.props.maxValue;\n  var pointerPath = gauge.pointer.current.context.pointerPath;\n  var pointerRadius = getPointerRadius(gauge);\n  var length = pointer.type == Pointer_1.PointerType.Needle ? pointerLength : 0.2;\n  var typesWithPath = [Pointer_1.PointerType.Needle, Pointer_1.PointerType.Arrow];\n  var pointerContext = {\n    centerPoint: [0, -pointerRadius / 2],\n    pointerRadius: getPointerRadius(gauge),\n    pathLength: gauge.dimensions.current.outerRadius * length,\n    currentPercent: utils.calculatePercentage(minValue, maxValue, value),\n    prevPercent: utils.calculatePercentage(minValue, maxValue, ((_a = gauge.prevProps) === null || _a === void 0 ? void 0 : _a.current.value) || minValue),\n    prevProgress: 0,\n    pathStr: \"\",\n    shouldDrawPath: typesWithPath.includes(pointer.type),\n    prevColor: \"\"\n  };\n  return pointerContext;\n};\nvar initPointer = function (gauge) {\n  var value = gauge.props.value;\n  var pointer = gauge.props.pointer;\n  var _a = gauge.pointer.current.context,\n    shouldDrawPath = _a.shouldDrawPath,\n    centerPoint = _a.centerPoint,\n    pointerRadius = _a.pointerRadius,\n    pathStr = _a.pathStr,\n    currentPercent = _a.currentPercent,\n    prevPercent = _a.prevPercent;\n  if (shouldDrawPath) {\n    gauge.pointer.current.context.pathStr = calculatePointerPath(gauge, prevPercent || currentPercent);\n    gauge.pointer.current.path = gauge.pointer.current.element.append(\"path\").attr(\"d\", gauge.pointer.current.context.pathStr).attr(\"fill\", pointer.color);\n  }\n  //Add a circle at the bottom of pointer\n  if (pointer.type == Pointer_1.PointerType.Needle) {\n    gauge.pointer.current.element.append(\"circle\").attr(\"cx\", centerPoint[0]).attr(\"cy\", centerPoint[1]).attr(\"r\", pointerRadius).attr(\"fill\", pointer.color);\n  } else if (pointer.type == Pointer_1.PointerType.Blob) {\n    gauge.pointer.current.element.append(\"circle\").attr(\"cx\", centerPoint[0]).attr(\"cy\", centerPoint[1]).attr(\"r\", pointerRadius).attr(\"fill\", pointer.baseColor).attr(\"stroke\", pointer.color).attr(\"stroke-width\", 8 * pointerRadius / 10);\n  }\n  //Translate the pointer starting point of the arc\n  setPointerPosition(pointerRadius, value, gauge);\n};\nvar updatePointer = function (percentage, gauge) {\n  var _a;\n  var pointer = gauge.props.pointer;\n  var _b = gauge.pointer.current.context,\n    pointerRadius = _b.pointerRadius,\n    shouldDrawPath = _b.shouldDrawPath,\n    prevColor = _b.prevColor;\n  setPointerPosition(pointerRadius, percentage, gauge);\n  if (shouldDrawPath && gauge.props.type != GaugeComponentProps_1.GaugeType.Grafana) gauge.pointer.current.path.attr(\"d\", calculatePointerPath(gauge, percentage));\n  if (pointer.type == Pointer_1.PointerType.Blob) {\n    var currentColor = (_a = arcHooks.getArcDataByPercentage(percentage, gauge)) === null || _a === void 0 ? void 0 : _a.color;\n    var shouldChangeColor = currentColor != prevColor;\n    if (shouldChangeColor) gauge.pointer.current.element.select(\"circle\").attr(\"stroke\", currentColor);\n    gauge.pointer.current.context.prevColor = currentColor;\n  }\n};\nvar setPointerPosition = function (pointerRadius, progress, gauge) {\n  var _a;\n  var pointer = gauge.props.pointer;\n  var pointerType = pointer.type;\n  var dimensions = gauge.dimensions;\n  var value = utils.getCurrentGaugeValueByPercentage(progress, gauge);\n  var pointers = (_a = {}, _a[Pointer_1.PointerType.Needle] = function () {\n    // Set needle position to center\n    (0, exports.translatePointer)(dimensions.current.outerRadius, dimensions.current.outerRadius, gauge);\n  }, _a[Pointer_1.PointerType.Arrow] = function () {\n    var _a = (0, arc_1.getCoordByValue)(value, gauge, \"inner\", 0, 0.70),\n      x = _a.x,\n      y = _a.y;\n    x -= 1;\n    y += pointerRadius - 3;\n    (0, exports.translatePointer)(x, y, gauge);\n  }, _a[Pointer_1.PointerType.Blob] = function () {\n    var _a = (0, arc_1.getCoordByValue)(value, gauge, \"between\", 0, 0.75),\n      x = _a.x,\n      y = _a.y;\n    x -= 1;\n    y += pointerRadius;\n    (0, exports.translatePointer)(x, y, gauge);\n  }, _a);\n  return pointers[pointerType]();\n};\nvar isProgressValid = function (currentPercent, prevPercent, gauge) {\n  //Avoid unnecessary re-rendering (when progress is too small) but allow the pointer to reach the final value\n  var overFlow = currentPercent > 1 || currentPercent < 0;\n  var tooSmallValue = Math.abs(currentPercent - prevPercent) < 0.0001;\n  var sameValueAsBefore = currentPercent == prevPercent;\n  return !tooSmallValue && !sameValueAsBefore && !overFlow;\n};\nvar calculatePointerPath = function (gauge, percent) {\n  var _a = gauge.pointer.current.context,\n    centerPoint = _a.centerPoint,\n    pointerRadius = _a.pointerRadius,\n    pathLength = _a.pathLength;\n  var startAngle = utils.degToRad(gauge.props.type == GaugeComponentProps_1.GaugeType.Semicircle ? 0 : -42);\n  var endAngle = utils.degToRad(gauge.props.type == GaugeComponentProps_1.GaugeType.Semicircle ? 180 : 223);\n  var angle = startAngle + percent * (endAngle - startAngle);\n  var topPoint = [centerPoint[0] - pathLength * Math.cos(angle), centerPoint[1] - pathLength * Math.sin(angle)];\n  var thetaMinusHalfPi = angle - Math.PI / 2;\n  var leftPoint = [centerPoint[0] - pointerRadius * Math.cos(thetaMinusHalfPi), centerPoint[1] - pointerRadius * Math.sin(thetaMinusHalfPi)];\n  var thetaPlusHalfPi = angle + Math.PI / 2;\n  var rightPoint = [centerPoint[0] - pointerRadius * Math.cos(thetaPlusHalfPi), centerPoint[1] - pointerRadius * Math.sin(thetaPlusHalfPi)];\n  var pathStr = \"M \".concat(leftPoint[0], \" \").concat(leftPoint[1], \" L \").concat(topPoint[0], \" \").concat(topPoint[1], \" L \").concat(rightPoint[0], \" \").concat(rightPoint[1]);\n  return pathStr;\n};\nvar getPointerRadius = function (gauge) {\n  var pointer = gauge.props.pointer;\n  var pointerWidth = pointer.width;\n  return pointerWidth * (gauge.dimensions.current.width / 500);\n};\nvar translatePointer = function (x, y, gauge) {\n  return gauge.pointer.current.element.attr(\"transform\", \"translate(\" + x + \", \" + y + \")\");\n};\nexports.translatePointer = translatePointer;\nvar addPointerElement = function (gauge) {\n  return gauge.pointer.current.element = gauge.g.current.append(\"g\").attr(\"class\", \"pointer\");\n};\nexports.addPointerElement = addPointerElement;\nvar clearPointerElement = function (gauge) {\n  return gauge.pointer.current.element.selectAll(\"*\").remove();\n};\nexports.clearPointerElement = clearPointerElement;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","exports","clearPointerElement","addPointerElement","translatePointer","drawPointer","d3_1","require","Pointer_1","arc_1","utils","arcHooks","GaugeComponentProps_1","gauge","resize","_a","pointer","current","context","setupContext","_b","prevPercent","currentPercent","prevProgress","props","isFirstTime","prevProps","type","GaugeType","Grafana","initPointer","shouldAnimate","animate","doughnut","transition","delay","animationDelay","ease","elastic","easeElastic","easeExpOut","duration","animationDuration","tween","currentInterpolatedPercent","interpolateNumber","percentOfPercent","progress","isProgressValid","clearArcs","drawArc","updatePointer","pointerLength","length","minValue","maxValue","pointerPath","pointerRadius","getPointerRadius","PointerType","Needle","typesWithPath","Arrow","pointerContext","centerPoint","pathLength","dimensions","outerRadius","calculatePercentage","pathStr","shouldDrawPath","includes","prevColor","calculatePointerPath","path","element","append","attr","color","Blob","baseColor","setPointerPosition","percentage","currentColor","getArcDataByPercentage","shouldChangeColor","select","pointerType","getCurrentGaugeValueByPercentage","pointers","getCoordByValue","x","y","overFlow","tooSmallValue","Math","abs","sameValueAsBefore","percent","startAngle","degToRad","Semicircle","endAngle","angle","topPoint","cos","sin","thetaMinusHalfPi","PI","leftPoint","thetaPlusHalfPi","rightPoint","concat","pointerWidth","width","g","selectAll","remove"],"sources":["C:/Users/Lenovo/Documents/ipondwebsite/node_modules/react-gauge-component/dist/lib/GaugeComponent/hooks/pointer.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.clearPointerElement = exports.addPointerElement = exports.translatePointer = exports.drawPointer = void 0;\nvar d3_1 = require(\"d3\");\nvar Pointer_1 = require(\"../types/Pointer\");\nvar arc_1 = require(\"./arc\");\nvar utils = __importStar(require(\"./utils\"));\nvar arcHooks = __importStar(require(\"./arc\"));\nvar GaugeComponentProps_1 = require(\"../types/GaugeComponentProps\");\nvar drawPointer = function (gauge, resize) {\n    var _a;\n    if (resize === void 0) { resize = false; }\n    gauge.pointer.current.context = setupContext(gauge);\n    var _b = gauge.pointer.current.context, prevPercent = _b.prevPercent, currentPercent = _b.currentPercent, prevProgress = _b.prevProgress;\n    var pointer = gauge.props.pointer;\n    var isFirstTime = ((_a = gauge.prevProps) === null || _a === void 0 ? void 0 : _a.current.value) == undefined;\n    if ((isFirstTime || resize) && gauge.props.type != GaugeComponentProps_1.GaugeType.Grafana)\n        initPointer(gauge);\n    var shouldAnimate = (!resize || isFirstTime) && pointer.animate;\n    if (shouldAnimate) {\n        gauge.doughnut.current\n            .transition()\n            .delay(pointer.animationDelay)\n            .ease(pointer.elastic ? d3_1.easeElastic : d3_1.easeExpOut)\n            .duration(pointer.animationDuration)\n            .tween(\"progress\", function () {\n            var currentInterpolatedPercent = (0, d3_1.interpolateNumber)(prevPercent, currentPercent);\n            return function (percentOfPercent) {\n                var progress = currentInterpolatedPercent(percentOfPercent);\n                if (isProgressValid(progress, prevProgress, gauge)) {\n                    if (gauge.props.type == GaugeComponentProps_1.GaugeType.Grafana) {\n                        arcHooks.clearArcs(gauge);\n                        arcHooks.drawArc(gauge, progress);\n                        //arcHooks.setupArcs(gauge);\n                    }\n                    else {\n                        updatePointer(progress, gauge);\n                    }\n                }\n                gauge.pointer.current.context.prevProgress = progress;\n            };\n        });\n    }\n    else {\n        updatePointer(currentPercent, gauge);\n    }\n};\nexports.drawPointer = drawPointer;\nvar setupContext = function (gauge) {\n    var _a;\n    var value = gauge.props.value;\n    var pointer = gauge.props.pointer;\n    var pointerLength = pointer.length;\n    var minValue = gauge.props.minValue;\n    var maxValue = gauge.props.maxValue;\n    var pointerPath = gauge.pointer.current.context.pointerPath;\n    var pointerRadius = getPointerRadius(gauge);\n    var length = pointer.type == Pointer_1.PointerType.Needle ? pointerLength : 0.2;\n    var typesWithPath = [Pointer_1.PointerType.Needle, Pointer_1.PointerType.Arrow];\n    var pointerContext = {\n        centerPoint: [0, -pointerRadius / 2],\n        pointerRadius: getPointerRadius(gauge),\n        pathLength: gauge.dimensions.current.outerRadius * length,\n        currentPercent: utils.calculatePercentage(minValue, maxValue, value),\n        prevPercent: utils.calculatePercentage(minValue, maxValue, ((_a = gauge.prevProps) === null || _a === void 0 ? void 0 : _a.current.value) || minValue),\n        prevProgress: 0,\n        pathStr: \"\",\n        shouldDrawPath: typesWithPath.includes(pointer.type),\n        prevColor: \"\"\n    };\n    return pointerContext;\n};\nvar initPointer = function (gauge) {\n    var value = gauge.props.value;\n    var pointer = gauge.props.pointer;\n    var _a = gauge.pointer.current.context, shouldDrawPath = _a.shouldDrawPath, centerPoint = _a.centerPoint, pointerRadius = _a.pointerRadius, pathStr = _a.pathStr, currentPercent = _a.currentPercent, prevPercent = _a.prevPercent;\n    if (shouldDrawPath) {\n        gauge.pointer.current.context.pathStr = calculatePointerPath(gauge, prevPercent || currentPercent);\n        gauge.pointer.current.path = gauge.pointer.current.element.append(\"path\").attr(\"d\", gauge.pointer.current.context.pathStr).attr(\"fill\", pointer.color);\n    }\n    //Add a circle at the bottom of pointer\n    if (pointer.type == Pointer_1.PointerType.Needle) {\n        gauge.pointer.current.element\n            .append(\"circle\")\n            .attr(\"cx\", centerPoint[0])\n            .attr(\"cy\", centerPoint[1])\n            .attr(\"r\", pointerRadius)\n            .attr(\"fill\", pointer.color);\n    }\n    else if (pointer.type == Pointer_1.PointerType.Blob) {\n        gauge.pointer.current.element\n            .append(\"circle\")\n            .attr(\"cx\", centerPoint[0])\n            .attr(\"cy\", centerPoint[1])\n            .attr(\"r\", pointerRadius)\n            .attr(\"fill\", pointer.baseColor)\n            .attr(\"stroke\", pointer.color)\n            .attr(\"stroke-width\", 8 * pointerRadius / 10);\n    }\n    //Translate the pointer starting point of the arc\n    setPointerPosition(pointerRadius, value, gauge);\n};\nvar updatePointer = function (percentage, gauge) {\n    var _a;\n    var pointer = gauge.props.pointer;\n    var _b = gauge.pointer.current.context, pointerRadius = _b.pointerRadius, shouldDrawPath = _b.shouldDrawPath, prevColor = _b.prevColor;\n    setPointerPosition(pointerRadius, percentage, gauge);\n    if (shouldDrawPath && gauge.props.type != GaugeComponentProps_1.GaugeType.Grafana)\n        gauge.pointer.current.path.attr(\"d\", calculatePointerPath(gauge, percentage));\n    if (pointer.type == Pointer_1.PointerType.Blob) {\n        var currentColor = (_a = arcHooks.getArcDataByPercentage(percentage, gauge)) === null || _a === void 0 ? void 0 : _a.color;\n        var shouldChangeColor = currentColor != prevColor;\n        if (shouldChangeColor)\n            gauge.pointer.current.element.select(\"circle\").attr(\"stroke\", currentColor);\n        gauge.pointer.current.context.prevColor = currentColor;\n    }\n};\nvar setPointerPosition = function (pointerRadius, progress, gauge) {\n    var _a;\n    var pointer = gauge.props.pointer;\n    var pointerType = pointer.type;\n    var dimensions = gauge.dimensions;\n    var value = utils.getCurrentGaugeValueByPercentage(progress, gauge);\n    var pointers = (_a = {},\n        _a[Pointer_1.PointerType.Needle] = function () {\n            // Set needle position to center\n            (0, exports.translatePointer)(dimensions.current.outerRadius, dimensions.current.outerRadius, gauge);\n        },\n        _a[Pointer_1.PointerType.Arrow] = function () {\n            var _a = (0, arc_1.getCoordByValue)(value, gauge, \"inner\", 0, 0.70), x = _a.x, y = _a.y;\n            x -= 1;\n            y += pointerRadius - 3;\n            (0, exports.translatePointer)(x, y, gauge);\n        },\n        _a[Pointer_1.PointerType.Blob] = function () {\n            var _a = (0, arc_1.getCoordByValue)(value, gauge, \"between\", 0, 0.75), x = _a.x, y = _a.y;\n            x -= 1;\n            y += pointerRadius;\n            (0, exports.translatePointer)(x, y, gauge);\n        },\n        _a);\n    return pointers[pointerType]();\n};\nvar isProgressValid = function (currentPercent, prevPercent, gauge) {\n    //Avoid unnecessary re-rendering (when progress is too small) but allow the pointer to reach the final value\n    var overFlow = currentPercent > 1 || currentPercent < 0;\n    var tooSmallValue = Math.abs(currentPercent - prevPercent) < 0.0001;\n    var sameValueAsBefore = currentPercent == prevPercent;\n    return !tooSmallValue && !sameValueAsBefore && !overFlow;\n};\nvar calculatePointerPath = function (gauge, percent) {\n    var _a = gauge.pointer.current.context, centerPoint = _a.centerPoint, pointerRadius = _a.pointerRadius, pathLength = _a.pathLength;\n    var startAngle = utils.degToRad(gauge.props.type == GaugeComponentProps_1.GaugeType.Semicircle ? 0 : -42);\n    var endAngle = utils.degToRad(gauge.props.type == GaugeComponentProps_1.GaugeType.Semicircle ? 180 : 223);\n    var angle = startAngle + (percent) * (endAngle - startAngle);\n    var topPoint = [\n        centerPoint[0] - pathLength * Math.cos(angle),\n        centerPoint[1] - pathLength * Math.sin(angle),\n    ];\n    var thetaMinusHalfPi = angle - Math.PI / 2;\n    var leftPoint = [\n        centerPoint[0] - pointerRadius * Math.cos(thetaMinusHalfPi),\n        centerPoint[1] - pointerRadius * Math.sin(thetaMinusHalfPi),\n    ];\n    var thetaPlusHalfPi = angle + Math.PI / 2;\n    var rightPoint = [\n        centerPoint[0] - pointerRadius * Math.cos(thetaPlusHalfPi),\n        centerPoint[1] - pointerRadius * Math.sin(thetaPlusHalfPi),\n    ];\n    var pathStr = \"M \".concat(leftPoint[0], \" \").concat(leftPoint[1], \" L \").concat(topPoint[0], \" \").concat(topPoint[1], \" L \").concat(rightPoint[0], \" \").concat(rightPoint[1]);\n    return pathStr;\n};\nvar getPointerRadius = function (gauge) {\n    var pointer = gauge.props.pointer;\n    var pointerWidth = pointer.width;\n    return pointerWidth * (gauge.dimensions.current.width / 500);\n};\nvar translatePointer = function (x, y, gauge) { return gauge.pointer.current.element.attr(\"transform\", \"translate(\" + x + \", \" + y + \")\"); };\nexports.translatePointer = translatePointer;\nvar addPointerElement = function (gauge) { return gauge.pointer.current.element = gauge.g.current.append(\"g\").attr(\"class\", \"pointer\"); };\nexports.addPointerElement = addPointerElement;\nvar clearPointerElement = function (gauge) { return gauge.pointer.current.element.selectAll(\"*\").remove(); };\nexports.clearPointerElement = clearPointerElement;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}